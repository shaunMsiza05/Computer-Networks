Chapter 1

Chapter 2 Review Questions

Homework problems and questions

section 2.1

R1 web application - uses http
email - uses smtp
dns - uses the dns protocol
correction:
File transfer - FTP, SFTP, or TFTP
Remote access - Telnet and SSH

R2 The network architecture is the infrastructure through which different hosts comunicate with each other and the application architecture focuses on how the sending and receiving communication processes of an application are implemented.

R3 The sending process is the server and the receiving process is the client.

R4 I don't agree. In the context of any giiven communication session, one side serves the data which the receiving side requests. The notion is only invalid in general because the p2p architecture doesn't require a dedicated sever.

R5 A port number

R6 UDP, UDP doesn't need to establish a dedicated connection to the server before communication begins.

R7 Correction: Internet telephony

R8 Reliable data transfer, security,
Correction: add timing and throughput 
TCP provides reliable data transer and security
UDP seems to provide mere data transfer, which isn't expected to be reliable.

R9 SSL works at the transport layer and is an enhancement of tcp. Forgot what the developer should do to use it
Correction:
SSL/TLS is often labeled an  Application Layer protocol, it technically acts as a shim between Transport and Application layers. It secures data before it's handed off to the transport layer. To use it, the application develop must import a TLS/SSL.

You should start wrapping your tcp connection with tls when socket programming.

section 2.2 - 2.5

R10 A protocol that begins with transferring control messages before data packets

R11. Because all these protocols run on application that are less-sensitive.

R12. The site can send a set cookie request to the client as part of a response packet. The request includes a unique id number generated for the client. If the user accepts this request, the browser will add the id mapped to the site in a cookie management file. On the site's database, an entry will be made with the primary key being the id assigned to the user. Now whenever the user visits the site, the browser will add the id mapped to the site as part of the requests and the website will add a purchase record to its database.

R13 If a user is running a web cache, then the html objects they frequently request are going to be cached by the web cache. this reduces delay as frequently requested objects will be retrieved directly from the cache, as opposed from the origin server. The cache will only reduce delay for some objects, namely, those it contains.

R14 Yet to telnet to a web server but I can try it on packet tracer

R15 Facebook, whatsapp, x, snapchat, and instagram. Presumably, their protocol architecture differs widely from  that used by sms.

R16 The message is pushed to Alice's mail server using http. Then Alice's mail server relays the message directly to Bob's mail server. Lastly, bob pulls the message into his end system using pop3.

R17 Skip

R18 The download and delete mode retrieves mail for the user but deletes it afterwards, which means that the user won't be able to access that mail from another device. The download and keep mode, on the other hand, allows the user to keep the mail after dowloading it so that he can retrieved it from his other devices, or even the same device if he's deleted it from his local storage.

R19 The rr type will be an mx record, which allows for domain names to be mapped to ip addresses of mail servers.

R20 SKIP

Section 2.5

R21 Bob will return the chunks in the same interval. Because Alice is consistently sending chunks to Bob, bitTorrent will give Alice a higher precedence, that is, Alice will be added to the unchoken list (forgot the name) of neighbours in Bob's lists of neighbours.

R22 Besides the top-four uploaders, bitTorrent also randomly selects a new user to be sent chunks of data for each active user, so that new users don't remain without data. And Alice will get her first chunk in this manner.

R23 Not sure, but I think it is a network built on top of another. A physical infrastructure underlies it, but the topology of the overlay includes logical links that connect the overlay nodes. The may be several intermediate devices between the overlay nodes, but the overlay node doesn't recognise them as part of the overlay network. Interestingly, the routes that carry traffic of these overlay network are not aware that the data is of an overlay network

Section 2.6

R24. There's the enter deep and bring home server placement philosophies. The enter deep option involves service providers deploying their server clusters at ISP all over the world. This option is based on the fact that most users access the internet through ISPs, therefore, ff server clusters at deployed at ISPs, requests can be fulfilled directly by server clusters if deployed at a user's access ISP. The bring home placement method, one the other hand, emphasizes deploying these server clusters at IXPs, which are centres where most ISPs or private networks multi-home. Unlike the former method, the server clusters deployed at these IXPs are comparatively larger and deployed strategically at several IXPs. Each method has its respective advantages and disadvantages. For example, two downsides of the bring home option is management overheads and maintainance costs. ? If the TCP server were to support n simultaneous connections, the tcp server will need to support n sockets.



R25.

R26.TCP supports two sockets because a dedicated connection between the sending and receiving processes must be established before data transmission. Whereas UPP is connectionless, meaning data can be sent without establishing a dedicated connection to the server.

R27. The tcp server must be executed first so that the client can establish a connection to the server. UDP, on the other hand, is  connectionless, which means theres' no way the client can determine beforehand if the server is running.

Problems

P1. A. True
B. False
C. False
D. False
E. False

P2. P2 Whatsapp as a secure communication app uses end-to-end encryption provided by the signal protocol to ensure that only sender and receiver can read the message. Using public/private keys assigned to each user, the message sent to a user, through his public key, can only be decrypted through his private key. Messages sent through the server are sent through a connection-oriented tcp channel, adding TLS and SSL to enhace channel security. To upload and download multimedia, the app uses http and https. Lastly, websockets are used to establish a dedicated connection to the server through which messages are sent and received. For voice and video calls, udp is used and enhanced with the srtp protocol which provides encyrption and authetication in real-time.  
Imessage is a proprietary application layer procotol used to transfer messages in the imessage app. For the transport layer, Apple uses its own protocol called the Apple Push Notification service. I couldn't discover the end to end encryption protocol used by the app, owing to the fact that the  info on the implementation of imessage is not publicly available, being a proprietary protocol. The IDS protocol, which is proprietary to Apple, is used to check if a receipient is an apple user, and if so, their public key is retrieved for session establishment. Lastly, for message encryption the app uses AES and RSA.

Lastly, the SMS system is a very interesting system. Firstly, a users must be connected to a cellular network in order to send and receive messages. And the access edge to the cellular network is a Base transceiver station, commonly known as a cell phone tower. Data is sent to this station and from it through a radio interface transmiting radio signals. These base transceiver stations are managed through a central node called a Base station controller. Thic central controller performs several functions, like transfering mobile devices from one station to another seamlessly. The messages are then transfered higher, to a node refered to as a Mobile switching center, this centre acts as a gateway to a cellular network and is a point through which data to the network is sent and received. But for sms messages, the data is first sent to an smsc, which is a centre dedicated to handling sms messages before they are transferred out or within the cellular network. Understanding this infrastructure is crucial to understanding the complexity of protocols used by sms. This is because some of those protocols are used to perform functions of these dedicated nodes. For example, SM-LL is used for physical transmission over GSM channels, the SM-TL (Transfer layer) handles message fomatting and delivery, and, lastly, the SM - RL (Relay layer) is used to route messages between network entities.


P3. If the url is given, then the client knows the domain name of the web server. Thefore, the application-layer protocol needed is dns to resolve the domain name to its corresponding address. And since dns runs on UDP, that will be the transport layer protocol requires in addition.

P4. 

Section 2.7

R26. Tcp uses two socket because it has to establish a dedicated connection between the two processes. The server will have need n * 2 to support n simultaneous connections from the user.

R27. A. gaia.cs.umass.edu/cs453/index.html
B. l HTTP/1.1<
C. A persistent connection. (Connection:keep-alive). Are post requests persistent by default?


P5. A.The server was able to successfully find the document signified by the 200 status code. Tue, 07 Mar 2008 12:39:45GMT
B. Sat, 10 Dec2005 18:27:46
C. 3874
D. The server agreed to a persistent connection

P6. Skip for now
 Obtain the specificaion

P7. a. Time = U + RTT0

P8.a Time = (U + RTT0) * 8
      I don't know if browsers temporarily cache ip addresses. My formula assumes otherwise, in which case, the time it takes to establish a connection and retrieve an object will be repeated 8 times for serial connections.
   b Time = (U + RTT0) * 2
      my reasoning behind this formula is that for the time it takes to establish a single connection, 5 parallel connections are established, and through them, 5 objects are retrieved. then twice the time it takes for a single connection, the remaning three objects will be retrieved.

   c. Time = (U + RTT0) + ((RTT0 * 7)
      my reasoning behind this last connection. So the intermediary dns RTTs and one RTT for the first object. Then the last 7  objects are sent without dns, but i am wrong that the last seven responses are rtt but rtt divided by 2, nope im wrong, even on the same persistent connection the requests should be made individually
U represents the sum of the rtts for each of the intermediate dns servers
Rtt0 represents the rtt for retreiving the actual object

P10
Data packets size = 100 000 bits long
Control data packets = 200 bits long
Bandwith = 150bps
N parallel connections = 1/N of bandwidth

download object = 100kbits long
initial downloaded objects contain 10 referenced objects

T
Consider non persistent http for the parallel downloads of the aforementioned


for a single connection = the time equals the rtt of the tcp handshake process, which is three way. I have to be as accurate as I can be

the three way handshake of tcp, before the retrival of the object. for simplicity, let's avoid other factors

retrieving the object will be:
let D be time
       D = 1.5 RTT (for tcp) + RTTo
for 11 objects, the time will be: D * 11. Especially since the connection is non persistent

let me consider now just one object
the link supports 100 kilobits
only one object can be sent at a time, as that is the MTU of the link
so the formula will be. time = RTT * 11 objects
since one rrt retrieve an entire object, multiply the time it takes by 11 will give us the ime it takes to retrieve all the objects.

so persistent http won't make a difference because of the MTU, but verify
but calculate the bandwith each parallel connection will get
= each connnection will get 9,09kbits of bandwidth. 
with parallel objects, retrieving the object will take

interestingly, at D time, about 100kbits are retriveed, which equals almost an entire object

To answer the question and stop babbling, parallel downloads are senseless because only one object can be retrieved at a time in correspondence to the MTU. Therefore, the requests will be executed serially. But persistent http will gain an edge because the number of required tcp packages for the handshake process will lessen, in contrast.

P12. I wrote the tcp program but headers that I couldn'd find a conditional get request header

P13 MAIL FROM identifies the sender, and from identifies the mail server, not sure


the non persistent 
P12 coded

P13

P14 I think it uses three full stops




